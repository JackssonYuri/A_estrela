# -*- coding: utf-8 -*-
"""A*(A Estrela)

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mierudl7hb5NxUtqTorcZtJTWvPN-SXi
"""

# importar bibliotecas
import numpy as np
import math
#realizar operações em arrays multidimensionais
import matplotlib.pyplot as plt
# biblioteca para criação de gráficos em 2d, acho interessante

# criar classes
# uma classe descreve todos os objetos de um tipo particular, permite organizar dados e funcionalidades juntos
# self: referenciar o próprio objeto(instância) para quando quando for fazer uso de metódos e também para utilizar atributos pertencentes e este objeto


class Vertice:
  
	def __init__(self, rotulo, distancia_objetivo):
		self.rotulo = rotulo  #nome da cidade
		self.visitado = False #se o vertice foi visitado
		self.distancia_objetivo = distancia_objetivo  #a distancia do vértice ao objetivo
		self.adjacentes = []  #lista de vertices vizinhos, crio um array com as cidades vizinhas 

	def adiciona_adjacente(self, adjacente): #função add_vizinho vai adicinando vizinhos 
		self.adjacentes.append(adjacente)
			# append adiciona ao final da lista

	def mostra_adjacentes(self): #funcao que vai mostrar as cidades vizinhas, mostra nome e custo de cada vizinho
		for i in self.adjacentes:
			print(i.vertice.rotulo, i.custo)

    # para cada objeto na lista de adjacentes, imprimo o nome do cidade e também o custo dela
    #vertice.nome pois estou querendo acessar o nome da cidade através de outra função


class Adjacente:  #o que os vizinhos tem(adjacentes)?
  
	def __init__(self, vertice, custo):
	  self.vertice = vertice
	  self.custo = custo
	  self.distancia_aestrela = vertice.distancia_objetivo + self.custo
      #f(n) = g(n) + h(n)
      #formula da distancia a estrela


class Grafo:
	arad = Vertice("Arad", 366)
	zerind = Vertice('Zerind', 374)
	oradea = Vertice('Oradea', 280)
	sibiu = Vertice('Sibiu', 253)
	timisoara = Vertice('Timioara', 329)
	lugoj = Vertice('Lugoj', 244)
	mehadia = Vertice('Mehadia', 241)
	dobreta = Vertice('Dobreta', 242)
	craiova = Vertice('Craiova', 160)
	rimnicu = Vertice('Rimnicu', 193)
	fagaras = Vertice('Fagaras', 178)
	pitesti = Vertice('Pitesti', 98)
	giurgiu = Vertice('Giurgiu', 77)
	bucharest = Vertice('Bucharest', 0)
  #instancio a cidade chamando a função vertice(recebe o nome dela e a distancia_obj)

  #Agora adiciono as cidades equivalentes a cada vértice

	arad.adiciona_adjacente(Adjacente(zerind, 75))
	arad.adiciona_adjacente(Adjacente(sibiu, 140))
	arad.adiciona_adjacente(Adjacente(timisoara, 118))
  #os vizinhos de arad são: zerind, sibiu e timisoara, em seguida o custo que é para chegar nessas cidades a partir de arad
	zerind.adiciona_adjacente(Adjacente(arad, 75))  #um dos vizinhos de zerind é arad, lembrando da volta
	zerind.adiciona_adjacente(Adjacente(oradea, 71))

	oradea.adiciona_adjacente(Adjacente(zerind, 71))
	oradea.adiciona_adjacente(Adjacente(sibiu, 151))

	sibiu.adiciona_adjacente(Adjacente(oradea, 151))
	sibiu.adiciona_adjacente(Adjacente(arad, 140))
	sibiu.adiciona_adjacente(Adjacente(fagaras, 99))
	sibiu.adiciona_adjacente(Adjacente(rimnicu, 80))

	timisoara.adiciona_adjacente(Adjacente(arad, 118))
	timisoara.adiciona_adjacente(Adjacente(lugoj, 111))

	lugoj.adiciona_adjacente(Adjacente(timisoara, 111))
	lugoj.adiciona_adjacente(Adjacente(mehadia, 70))

	mehadia.adiciona_adjacente(Adjacente(lugoj, 70))
	mehadia.adiciona_adjacente(Adjacente(dobreta, 75))

	dobreta.adiciona_adjacente(Adjacente(mehadia, 75))
	dobreta.adiciona_adjacente(Adjacente(craiova, 120))

	craiova.adiciona_adjacente(Adjacente(dobreta, 120))
	craiova.adiciona_adjacente(Adjacente(pitesti, 138))
	craiova.adiciona_adjacente(Adjacente(rimnicu, 146))

	rimnicu.adiciona_adjacente(Adjacente(craiova, 146))
	rimnicu.adiciona_adjacente(Adjacente(sibiu, 80))
	rimnicu.adiciona_adjacente(Adjacente(pitesti, 97))

	fagaras.adiciona_adjacente(Adjacente(sibiu, 99))
	fagaras.adiciona_adjacente(Adjacente(bucharest, 211))

	pitesti.adiciona_adjacente(Adjacente(rimnicu, 97))
	pitesti.adiciona_adjacente(Adjacente(craiova, 138))
	pitesti.adiciona_adjacente(Adjacente(bucharest, 101))

	bucharest.adiciona_adjacente(Adjacente(fagaras, 211))
	bucharest.adiciona_adjacente(Adjacente(pitesti, 101))
	bucharest.adiciona_adjacente(Adjacente(giurgiu, 90))


grafo = Grafo()  #chamada da função grafo, instanciando um grafo

class VetorOrdenado:  #armazena as cidades adjacentes
    #vetor ordenado = vai fazer comparação com o valor de uma cidade com a próxima, sempre percebendo se é maior ou não
    def __init__(self, capacidade):
        self.capacidade = capacidade
        self.ultima_posicao = -1  #se o vetor ordenado for definido como vazio a ult posição será -1
        #mundaça no tipo de dados
        self.valores = np.empty(self.capacidade, dtype=object)
#atributo valores recebe um array empty(vazio), que recebe como parâmetros a capacidade e como tipo de dados objeto
#dtype descreve o tipo de elemento no array

# Referência para o vértice e comparação com a distancia para o

    def insere(self, adjacente):  #vai inserir o adjacente
        if self.ultima_posicao == self.capacidade - 1:
            #caso a ultima posicao seja a capacidade total -1 está na capacidade máximo, imprime a frase e dá o return para parar a exec
            print('Capacidade máxima atingida')
            return
        posicao = 0  #intancio a variável posicao como 0
        for i in range(self.ultima_posicao + 1):  #percorre todo o vetor
            posicao = i
            if self.valores[
                    i].distancia_aestrela > adjacente.distancia_aestrela:
                #se o array vetores da distancia_aestrela for maior que o adjacente da distancia_aestrela finaliza a busca
                break
            if i == self.ultima_posicao:  #caso para atualizar ultima posição
                #caso necessite adicionar na última posição
                #tenho que fazer o caminho inverso
                #ver aula disso de busca inversa
                posicao = i + 1
        x = self.ultima_posicao
        #crio uma variável auxiliar que recebe ultima posição
        while x >= posicao:
            self.valores[x +
                         1] = self.valores[x]  # descola valores para inserção
            x -= 1  #vou decrementando a cada vez que percorre
        self.valores[posicao] = adjacente
        self.ultima_posicao += 1


#função que vai imprimir as cidades adjacentes
    def imprime(self):
      if self.ultima_posicao == -1:
        #verifica primeiro se o vetor está vazio
        print("O vetor esta vazio")
      else:
        for i in range(self.ultima_posicao + 1):
          print(i, ' - ', self.valores[i].vertice.rotulo, ': Distância da atual: ',
            self.valores[i].custo, '/ Custo: ',
            self.valores[i].vertice.distancia_objetivo, ' / Função de Avaliação: ',
            self.valores[i].distancia_aestrela)


class AEstrela:
    
	def __init__(self, objetivo):
		self.objetivo = objetivo  # --- self.parametro -->atributo
		self.encontrado = False

	def buscar(self, atual):  # função de teste de objetivo, aqui mostra a cidade atual que estou(nó atual)
		print('\n')
		print('Atual : {}'.format(atual.rotulo))
		atual.visitado = True  # marca c atual como visitado, atual foi inicializado como False antes

		if atual == self.objetivo:  #marcação para me informar que cheguei no objetivo(bucharest), se for o parâmetro encontrado recebe True
			self.encontrado = True
		else:
			vetor_ordenado = VetorOrdenado(len(atual.adjacentes))
            #caso contrário, cria um vetor_ordenado com tamanho da quantidade de adjacentes, o vertor ordenado guarda os adjacentes do nó atual, os vizinhos da cidade(nó) atual
			for adjacente in atual.adjacentes:  #percorre a lista de vizinhos do grafo atual
				if adjacente.vertice.visitado == False:  #se o vizinho ainda não foi visitado
					adjacente.vertice.visitado = True  #marco ele como visitado
					vetor_ordenado.insere(adjacente)  #insere dentro de vetor ordenado como vizinho do nó atual

			vetor_ordenado.imprime()  #mostra vizinhos do nó atual, o vetor ordenado guarda todos os vizinhos do nó atual

			if vetor_ordenado.valores[0] != None:  #o vetor ordenado ta em ordem crescente
                #inicio é diferente de none? existe algo? se tiver algo faremos uma busca a partir do indice 0 dentro do vetor ordenado, o vertice é pq é uma cidade, esse valor será a cidade com o menor valor da função de avaliação f(n)
				self.buscar(vetor_ordenado.valores[0].vertice)

busca_aestrela = AEstrela(grafo.bucharest)  #testo a função então instanciando ela com o objetivo de se chegar a bucharest
busca_aestrela.buscar(grafo.arad)  #partindo de arad


#src e end  uma class 
def heuristic(src, end):
    # formula heuristica utilizada para calcular a distancia entre dois pontos
    # neste caso, distancia euclidiana

    
    return (src[0] - end[0]) + (src[1] - end[1])

    print(src[0])


def graphPlot(grafo, comeco, goal, rota):
    arestas = []
    #separar info
    for num in grafo:
        for i in grafo[num][1]:
            if (i, num) not in arestas:
                arestas.append((num, i))
    # plotar(coloca as aresta no grafo) arestas
    for a, b in arestas:
        plt.plot((grafo[a][0][0], grafo[b][0][0]), (grafo[a][0][1], grafo[b][0][1]), c = 'yellow')
    # plotar nos
    plt.plot([grafo[num][0][0] for num in grafo], [grafo[num][0][1] for num in grafo], '.',c='black')
    plt.plot(grafo[comeco][0][0], grafo[comeco][0][1], 'o')
    # plotar rota, inicio e fim
    plt.plot([grafo[i][0][0] for i in rota], [grafo[i][0][1] for i in rota], ls='--', c= 'red')
    plt.plot(grafo[comeco][0][0], grafo[comeco][0][1], marker = 's', c = 'green', label='começo')
    plt.plot(grafo[goal][0][0], grafo[goal][0][1], marker = "X", c = 'red', label='objetivo')
    plt.grid()
    plt.legend()
    plt.show()

def AStar(grafo, comeco, objetivo):
    G = {} # distancia desde o no inicial para o proximo
    F = {} # distancia estimada ate o destino
    H = {} # distancia heuristica do no N ate o destino
    G[comeco] = 0
    F[comeco] = H[comeco] = heuristic(grafo[comeco][0], grafo[objetivo][0]) # F = G + H, como G = 0, entao F = H
    anterior = {}
    visitou = set()
    queue = set([comeco])


    
    while len(queue) > 0:
        esseNo = comeco
        esseF = float('infinity')
        for i in queue: # percorre a fila atras do menor F
            if F[i] < esseF or esseNo == comeco:
                esseF = F[i]
                esseNo = i

        # testa se o atual eh o destino
        if esseNo == objetivo:
            route = [esseNo]
            while esseNo in anterior:
                esseNo = anterior[esseNo] # se sim, refaz o percurso para registrar a rota e plota o grafico
                route.append(esseNo)
            route.reverse()
            print(route,"\n") #F[goal]
            graphPlot(grafo, comeco, objetivo, route)
            return
 
        queue.remove(esseNo)
        visitou.add(esseNo)
        for adj in grafo[esseNo][1]: # checa os nos adjacentes
            if adj in visitou: # se ja tiver passado por ele, continua
                continue
            # senao, calcula o G
            adjG = G[esseNo] + heuristic(grafo[esseNo][0], grafo[adj][0])
            # se adjacente nao estiver na fila, o adiciona
            if adj not in queue:
                queue.add(adj)
            # testa se o G atual eh maior que o ja salvo. Se sim, ignora
            elif adjG >= G[adj]:
                continue
            # se nao, atualiza os dados
            anterior[adj] = esseNo
            G[adj] = adjG
            # calcula H se ja nao tiver sido calculado antes
            if adj not in H:
                H[adj] = heuristic(grafo[adj][0], grafo[objetivo][0])
            F[adj] = G[adj] + H[adj] # calcula e armazena F

# Grafo
# Formato: { no : [(coordenadas), (conexoes)] }
# Grafo
# Formato: { no : [(coordenadas), (conexoes)] }
Grafo_no = {
    #Que fazem fronteira com  buscareste
    'A': [(44, 30), ('B','C','D','E')],          # A = bucareste  
    'B': [(41, 22), ('A')],                      # B = Giurgiu
    'C': [(52, 33), ('A')],                      # C = Urziceni                   
    'D': [(30, 45), ('A','F')],                  # D = Fagaras    faz fronteira com   bucareste(A) e sibiu(F)
    'E': [(34, 33), ('A')],                      # E = Pitesti

    'F': [(20, 46), ('D','G','K','H')],          # F = Sibiu      faz fronteira com Arad(G)
    'G': [(6, 49), ('F','I')],                   # G = Arad
    'H': [(14, 60), ('F')],                      # H = Oradea
    'I': [(9, 55), ('H','G')],                   # I = Zerind
    'K': [(22, 38), ('F','E','J')],              # K = Rimniue Vilcea
    'J': [(22, 24), ('K','E','L')],              # J = Craiova
    'L': [(11, 26), ('J','M')],                  # L = Dobreta
    'M': [(11, 33), ('L','M')],                  # M = Mehadia
    'N': [(10, 40), ('M')] ,                     # N = Lugoj
    'O': [(2, 44), ('N','G')]                    # O = Timisora 
}
comeco = 'G'
objetivo = 'A'
# começo = Grafo_no['A'][0]
# objetivo = Grafo_no['F'][0]


print('\n','1: Arad(G)\n','2: Sibiu(F)\n','3: Rimniue Vilcea(K)\n','4: Bucharest(A)\n')

AStar(Grafo_no, comeco, objetivo)